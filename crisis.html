<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Passphrase"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"40a36ba24bc88191d272a14bd1caf4b5b4f139671925450920c76dd9f70c18b9ee518b1c0bb190da164013fcbb3c23570be5c61ef465fdb73374d46809ec6cb997ff75be297f78f9b4027c1bd9fc71576cc08e5160d1d1e9a44f16021ce03d06660be5b06f000acb4a7a4001c8e755acadf6855a5ac634e1cc1f6a2fd2540c1138809d6d914983a5a497f314c0fed68c849d83009beb1d52ce1026c29c6e88c0f2f99f7508742c222caca0702fd3be23f05ee485a0badbba1c7153381e804e9b0cbd53aba642f638288fdc7416a99a0830f7c1b790193a8c8b783dd64db9e1d90675b3b11870856506d7d183506086899e4b549d6e1241239f658243f808cbc70c7637f8b0eb563ff7eae26d43440ce210f8084af6583fc0951987f235b258d8d611a890b108b9b04dc8225eaaaacbf7adf66328c21bcd4dc88135d4e94d9e45fbb6db687c86fa4543532debeb8fbc46aadd5c8f31ebc12fae1cfeb215c7954e1265f0f73596f2fefa49162f21aafbfea5ca8f293e0cfaa9669e192cdae20be6e154695ccd1d8292c8355d4944c80100a95403a9096e374a12dc4955871f64d2b089e00c6a20357c058169579a5ec7adfcbe8eca267b534cb024dea18cba1f371c6d37ea3341d40ea87fc8704f5ae8032f43f86f858a1abf276d8caa0ba313561490d7b1fae5328c77e02a6a1362e6fbf038369d62e3b6ebe9368d8a5d5dec512169711f947d38d70a36881266b8e3b92b4361e88f76b1cf171f4cbeaff0dbcf105158e140152127123ca9149ec83516b792c3eea33f3008a05907cacbe54e781a723cd8af9c570888d3b31adf8c2346c7237e5701035ef2f77b1f17e5bfd38106fe8d0bc5ec8bb7b828658977ec82db4d37109de8de66c314e4062ed789926d18938dbe717a2f3372eef73c7f28f098b0bfc20f83ac985f872f44ebf5c031bd81a4a86cc14b4c443558968daeefd1c042a993768b64c86332712b5071eea582ca6b0a1d90ae16f9c0249f88d4791dbd5e61bfe179c3fdb968da1d3f108ff8e586a6ae394779b4f257c5d24a714922749be87398ee8cce18cc67718391c32ea53d35d407bd9cb60ddf13fc0ef8178ec45678850d39ca476cddabab0af385ce5b32abc0dc90d37372ecbe6fe48f9dfe239aecbfcc5b23bc587e91ee51908567a5354eb9d8362558df0774be60835ed9583c657335fd301e351272abd239a492aa40b8a8065381aa94ad1a4460d4cf0fbe02676d985f2a0a226598b2ddb698ed30053152e84e6f895b07cf32a690582a9c0636a7218c8d750c57454ef2cfe880bf64f60b7107ba9e9ec6a9cd7dc59e6d4f7d18540ef3cef99682d362af3433d837def2e9f01e881ac32975e73a1e4c21349bce0ee93188a8903c8a05848e8d4b85bc5a6433601e8957aebf6929b39dac8a0c6d6a8c3463dd4bcbb90e2ecb82c925ec5d3b3f7811a19761a10f07e0b646f0629c6580f88a2133dc1f89401f7ef3ba2ebfbafbbf839d91d9b9f9fbb8539d8c3a8af1e85f4e9e9e53bd3697151ef95a094b829a8bc47d963e31a5ae40bf779c579deb110844bfacfc978eb621ef702210bdc8ab9537ccd81c59d1ecf2fbc53224ad99387492c15a3aceba97907a33ce7a085515f4f23da88e0e22beadf1c245b9a1997eb02782c5bd96569131fbe4bedaf4010cfa8578c5338153f5d9411ef7739c11eb66c883f23eebf007739dd8628481f93dc9426fc31382f2e232e3380403351f58a0a78d0704647b16c07137cf96192176734a81042a1a499164b6b54692b390dd3f4ebb219ab418ca462834e964b7b29ffd409d68dfec1b764674d2bfbe1e091e159c869bd96eb1c542c5cb5c8232babdc1b2128422ce62584d50fecd1c4d4dbff78214110cb42d3466cc0c7301a26eec31013ee5e391515c821168fe87c3c5c1a480504c00cd6a34eabc02fe2d3039ea165e440f7890799024e30eb3f460ddee02e430dcdd0a9eae166b4a21e4a685c8000e333e0bdd01bee84a6bdbab0d4af7605ae94098ab98b2cb4fa1dd427d11af89427a7bce494b1490d113ff93619819a6793f422da500d053bc848e57df8037e71ba78851575b83fa5b8d464af3abe69bd72782515cfc4cd388d8f7175d7a15fe7a1523731b6e026c2f2471d2df1b1428feeeeddee09250e86010677e8d34032912d31cfc1bad06a81dc749451b5ff91b76492846be7f6a188ce27383bdd0d30f1f64f451a113d59013ea2d1b1ca7305c63cce7effa6a7577cba670947a9eda9f615a464d1aeba5a07a144b07a095b4e0084c2f772d9fae8fa69e931516a125a26f8a4c430787b5ae7d4a94dab5c8692d0dde4b93183c563e5c5ab2444492a5ab6ed6cc2e0c389f975714c1c48334105e25f929302ea1a641ac51f0a4f22b0bff5e9246cb8a1d4806a3666b5fe5bb999f71989505cb77ba5c8045dca724d01eff8e3c0fb6919da096b21cdeee435ce5267af15a11a86833b5c0b2726152f62ad930d412508744fab2b202c9c5dd711dfcfb6ef9cffd9e38e677c09d3bb6d18d9f1c3ba5ed2f58ab556f68e1ce18238f00b4f232c2fb5a8ca6d96638875f33f9e424aa81319fc5a355ecce3c8c7ad2bad0a404c40e0fa4015d36e9ac21d39d893e37c9debd11ff7beaebf8a1cba02c451231dd06564b7debc10de4f052cd6f22daa5fc997dd842eb0af4e4a7e25749fe01596c2efbbf09b62ba0209afdfd17a619953109c2d81985367c3afdfb04d858b4a020d6b9377529f0eb25dca92a4f3505bcb3f4d6fa66aa9939fdb25b929e122fca9e903eb5bb4e9161dc00614b91d7d05ce7a680510adb7b0f8daa3a6f97f3fe93debc1295e4b4951e2b5292e2cd7da5cb610e156b40aedf618fe029c85f7c9813a05a21fbc68bf052a438265c102f0013a6b447008cbae5fc19c0848b1581a085170dce49d3705d2541a0a0057ad08d0d88cc795094f7d02f2b1a2fd7d42a4b2f5c570dc64697896ca763f4089b16e991616dd7c024a0372b0351615a8366455c7bee603a11fcb5ad9c51869d59ffc46a58d10cfd379f7ed2418adb659fdfffedf37838e32d89292c8116c9e99fc3bce99c256ae3e1a8675be4735480d07d735c1e6c68f2617d9a809aaafefbd2546ae97ddb7290a75ac505fc389ba0c8f5de9bec78455963102b47c02813b19b0f92cfa946303dc0ea560ed406db760494b51d7436fdfdce6fc9393fbe9a7d097c11b43890b084e0ff7ad40433f0d01bdc1008932b7d88e63115b1a2b889e9dce47434f59bc860bdfe7beb74080f26608aac8b2f357f3a0c21956f4cae65c8d6f69a8b397f25c0a38b6f1122ddf709cd078d31ef35b04ddaa6bdc3dc9a8b507f23b56660e680f223ba703f674995059fc90f42459238a673464959f439452d7330e3e5c2db82d42ed06aba24b3e25904415891fa86f33dc458f49f76db490500772117e1c2db9b9625d2bdde7f556b1cfcf70d8ae3b38aafac1c73c2a4b5d1add4e7d1a73e2197e6893eca6def53befb8d54e54b374bf197d24e19a78df3bb8c439628c770cf9127932ac679c45f7be3ccb5ffc6c7c71916a355fce363d103e76c3112c27a70796bd9a8400d30218083f95de115ecc6243e077fe056835fc8700e16f70f6060e8975c2c8d661ee73746715d24fbd7e2f46d82689571ebf993b59e54d2a1852f3e01e5a8b8512b6786be1dc8c4e5331b7263571046bf90baeecc9257ffb109545ce08e91825283d2b6bf71b6b955699d9504ad1d75b0725bcdf182d9124cbb4bd02a8c1935fea3bd54d760651c3f15a2cc6adf859c1f6e121fe0d19e1095304f041e98c8bb509875d98399c18e12a0f2cf7455d79923df876fed0770e6c02ae557e988b2ebb7fd2a735e3602c47056651e02dcbf6a9b9c8ed851c899e8362b61407c9520a7421a3726f5a47ee81937121f93fba8c05819817cd86ee9bb6ff38ffc08ea6480ecb2e0c48ff1bde684cc69f500849c434b55f21fcd0676614eb359109200abce66de8953a8dfc989eb65477ebebc2ac0689342c7c8d2efd1f028638c094d5867dbb52611f407c66e39fae7369ce0cab87fc59ebd89ee926cc6a1368998f56ea8c0f9883293021fd40684dc587c17aac4823cb64b9259c99425016eb27a6d5976963314533c877af12965798294385d7a16b94ad61f534d91dd4448d92e27dc0f90227a8ad89bce232920d41e7439a47693624cf9d11b29e88c9a22b73e97be151b0785dfe517008bf4eb99e48f4e54a67e463f6bb10b832aee2e097dbfc9f911b8968781dd24936200b4f5c6fd6e01ed4fe5528761a24cb5bc557b5765200c1c85eebbce059c9149a0c42f7c88cab1802019c56e62e6b2085fab27969400e1da4eb959e880fd567724c779fcae4f687b10d882c0880c2202fcdad7769f9d6b6bb99938a3885538dbf9f91b9e32095fc07aef7520be12dd1bbd5b460bcf1dc5ea28701c9a29b8353b509e38425cab53b6db8a73df0199dc3df5c724f12dd3930b9eb1796ee4e258a2c9db9a68a7a7e6ae249ae8c44ef3eceb38b51106f18551a4eb475e9096cb058800fd6a9738ee7957039a5afd2f0b94d27464559557188851621763964cd66fd080385d77652ea2c2c576f160f4c3b2a87a8b3c6d01dbe196255b2c77782b356e2eedd1a8b370fc6384c6140d6a4d62af8ecb769837d32b13ab971d1b775f6265b8f7ab7724621a555a2019705f3b1da46e467589983ac0dbf974740148fc67024ebecbaaf46be7155df9329e6f6b2d71463ded878d532f16df3a2885292bb25e1ede673b992d1543086b3ada5343f5477af9210dff2f11a7049180dd32f1020122903f3d631854847107b462494053576f237f48f5167c708b604ae93a35a86d22f570b0608141876b8277a8d9a5812599fa1d198e049d9be05fa34f8c7991879d2ef74dbbfaf1d725bc7f50a178ec24a1e3a4935bdf9d8f2be9a3335094d74b72ea71e4c8f174ff7526f75655f5f82bc0be4441aec9190c77bd8c69f4f74881359961d518b756e0d63b1608861959361b38d6ad2efae0b6362d2434411e90ccb74d9f0439b07a4118fb641afb8fc28b80acbc3cf6ce8c8d98a98a937ac134c8ef38447a259dfe8aacc955295e8aac7ba179dc298aa7cc1f54d1021fd36384b01633c4490aece544fbafb04dccf266d0fad2cd4140228c0d393afa37cd4c88ad58f8d193117a7c54739961f8613ce121072093aee7f6b10eab6d1c0903715c758293cd9d9f22e96a20ee196635fee4e5b6a5ea78e46c17851cea57a1401a775c2d5d0d4c8181a8559b2c57ecfb804071dd76706c71c848d5e552492dcf2823c031553cabb3f899eb0343de75444cbb69e4e5818309314aa58c775466b36ed6c16a7fdd4dd4b56a2f0e27a827bdff8335428b470cebb7ba1f1b64486dbd85eaf2a6be055f3b0ac7d986459b6978973051d2029a6c01ab54929270fa59fd507e1e52a2d811a7a25a3155b080dae18fc5be2f516c43df3d3f9f230923dbc8bab1e0fa759189d8bccd3fe98e108e1b88593150bf6577226784bba819dded22827f0639b591fc9346d987389056c3836beddc2f150151864930a8838c9ffe5a4531284dfeeb081ce4993e50cb6b65f1de916696246c6eb9a5d1257f7af9bfd8a9689bcdb3b48c068bd84b49d5587feec10397f92e077a8d7d7859236725566520ccf4cb8957396f9baef67789fce96d7539c70a4aca92ad26404c7ce5d7fab19dbdfc01bee379888057b3367a87c2fe80cf4eab2ffd08da53b0a1e7d83854b71fb99220d66388a5747886064b7968f896dcab7a1325542622d88eab21e9f0a51a455f014927df3cf90ee8e28c782ec253e7c341de25823c37e7a0b1a144ee232955c5fc3a181965e1beb8db11948bc76133765325334ff72e3f47113828ab00fca0885b5a4cb71909d5fc915c0fa660e35512896d0b9368e2718d14cab0ab0c0e65f6e8b4d7638f96ffaff69de5c9769102a9034f7e7bebfc3e54e59c3539a916de1d360317c6529199476cfc47cb051a278d6ee99ba7cb91570e42100a1c22f38cfe8f6c489fafdaf55841e1ead3b9f3f55a6e8d8014699fe1028908d4ac3e4ab259a7eb2940ce6d14e1fccf427d394efa617ccaeb87e2fe64be8c1d0c7354440b2cd4b70d4f090c691c9d352d0725b02ed895448700d22c3b599a35f86756a0f24ba2f8689ab4427e36c517228febc95b884c3d9042661afd2a9ed95d94a2bf9c1eaee7ba09980c3da2ce0ec328b7f2fe5922d9f20ba8b6c1157bfdd5cef5eed345adeceedf8c480350b377d76cfcd4fd2802b95b849fab94e317e6e061882b00c4a6620468e369a738d9fa3945b448d69d61dc0b14ea5452150df929926df0e9af21d48e59dc271221246751681050ce428070fdfe4a9918ca889e9c6dcafce823aa99ddcd67b452c9249a5262799ab77fcfe50eb1f7214c74c612922c6adafa22c6fff7426a7a5382b78a75d3993000444a6ec95246d868ac794ed8749bed15320cf62b3a5aa347e57c69ad0e1677ef7d8457441d999538ce6f0cad4482c6679803adfc54ee91d1b9824a5bfb85a8061be489660f369a67b12f70","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"ac5d49e5a16119d464d17a3ae53e7353"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
